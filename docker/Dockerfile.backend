# syntax=docker/dockerfile:1.4
# =============================================================================
# CRM Backend - Optimized Multi-Stage Dockerfile
# =============================================================================
# Features:
#   - Layer caching for faster rebuilds
#   - Separate restore and build stages
#   - Minimal runtime image
# =============================================================================

# ============================================
# Stage 1: Build (restore + compile)
# ============================================
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS builder

WORKDIR /src

# Copy only project files first for layer caching
COPY CRM.Backend/CRM.sln ./
COPY CRM.Backend/src/CRM.Core/CRM.Core.csproj ./src/CRM.Core/
COPY CRM.Backend/src/CRM.Infrastructure/CRM.Infrastructure.csproj ./src/CRM.Infrastructure/
COPY CRM.Backend/src/CRM.Api/CRM.Api.csproj ./src/CRM.Api/
COPY CRM.Backend/src/CRM.DatabaseSeeder/CRM.DatabaseSeeder.csproj ./src/CRM.DatabaseSeeder/

# Restore dependencies (this layer is cached unless project files change)
RUN dotnet restore CRM.sln

# Copy all source files
COPY CRM.Backend/src/ ./src/

# Build and publish (combined for reliability)
RUN dotnet build CRM.sln -c Release && \
    dotnet publish "src/CRM.Api/CRM.Api.csproj" -c Release -o /app/publish --no-build

# ============================================
# Stage 2: Runtime (minimal image)
# ============================================
FROM mcr.microsoft.com/dotnet/aspnet:8.0-alpine AS runtime

WORKDIR /app

# Install minimal dependencies including ICU for globalization
RUN apk add --no-cache curl mariadb-client icu-libs icu-data-full

# Create directories with proper permissions
RUN mkdir -p /app/data /app/ssl /app/wwwroot/uploads/logos /app/wwwroot/uploads/users /app/wwwroot/uploads/customers /app/wwwroot/uploads/contacts && \
    chmod 777 /app/data && \
    chmod -R 755 /app/wwwroot && \
    chmod 755 /app/ssl

# Copy published application
COPY --from=builder /app/publish .

# Note: SSL certificate should be mounted via Kubernetes secret, not baked into image
# Example K8s volume mount: /app/ssl/server.pfx

# Create startup script
RUN printf '#!/bin/sh\nset -e\necho "Starting CRM API..."\nif [ -f /app/ssl/server.pfx ]; then\n  echo "SSL certificate found - HTTPS on port 5001"\nelse\n  echo "No SSL - HTTP only on port 5000"\nfi\nexec "$@"\n' > /app/entrypoint.sh && \
    chmod +x /app/entrypoint.sh

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
    CMD curl -f http://localhost:5000/health || exit 1

EXPOSE 5000 5001

# Environment configuration
ENV ASPNETCORE_URLS=http://+:5000 \
    DOTNET_CLI_TELEMETRY_OPTOUT=1 \
    DOTNET_RUNNING_IN_CONTAINER=true \
    DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=false \
    SSL_CERT_PATH=/app/ssl/server.pfx \
    SSL_CERT_PASSWORD=CrmSslCert2024 \
    HTTPS_PORT=5001 \
    HTTP_PORT=5000

ENTRYPOINT ["/app/entrypoint.sh"]
CMD ["dotnet", "CRM.Api.dll"]
